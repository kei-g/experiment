jobs:
  gpg-sign:
    name: GPG Sign
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1
          persist-credentials: false
          ref: ${{ github.event.ref }}
      - id: gpg
        name: Import a GPG key
        uses: actions/github-script@v6
        with:
          script: |
            const child_process = require('node:child_process')
            const process = require('node:process')
            const { env } = process
            const { execSync } = child_process
            const { mkdtempSync, unlinkSync, writeFileSync } = require('node:fs')
            const { tmpdir } = require('node:os')
            const { sep } = require('node:path')
            const fingerprint = `${{ vars.GPG_PRIVATE_KEY_FINGERPRINT }}`.split('\n').filter(
              line => line.match(/^[0-9A-F]+$/g)
            ).join('\n')
            const keyPath = [
              mkdtempSync(
                [
                  tmpdir(),
                  '.import-gpg-key-'
                ].join(sep)
              ),
              'key.pgp',
            ].join(sep)
            const privateKeyData = `${{ secrets.GPG_PRIVATE_KEY }}`.split('\n').filter(
              line => line.match(/^[0-9A-Za-z\+\/\=]+$/g)
            ).join('\n')
            const passphrase = Buffer.from(
              `{{ secrets.GPG_PASSPHRASE }}`.split('\n').filter(
                line => line.length
              ).join('\n'),
              'utf8'
            ).toString('hex').toUpperCase()
            writeFileSync(
              keyPath,
              Buffer.from(privateKeyData, 'base64'),
              { mode: 0o600 }
            )
            await core.group(
              'Import a GPG private key',
              () => new Promise(
                resolve => {
                  const gpg = child_process.spawn(
                    'gpg',
                    [
                      '--batch',
                      '--import',
                      '--yes',
                      keyPath,
                    ]
                  )
                  gpg.on('exit', setTimeout.bind(undefined, resolve, 1000))
                  gpg.stderr.pipe(process.stderr)
                  gpg.stdout.pipe(process.stdout)
                }
              )
            )
            unlinkSync(keyPath)
            writeFileSync(
              env.GNUPGHOME ?? [env.HOME, '.gnupg', 'gpg-agent.conf'].join(sep),
              [
                'allow-loopback-pinentry',
                'allow-preset-passphrase',
                'default-cache-ttl 21600',
                'max-cache-ttl 31536000',
              ].join('\n')
            )
            writeFileSync(
              env.GNUPGHOME ?? [env.HOME, '.gnupg', 'gpg.conf'].join(sep),
              [
                'pinentry-mode loopback'
              ].join('\n')
            )
            const connectAgentAsync = (name, command) => core.group(
              name,
              () => new Promise(
                resolve => {
                  const agent = child_process.spawn('gpg-connect-agent')
                  agent.on('exit', resolve)
                  agent.stderr.pipe(process.stderr)
                  agent.stdout.pipe(process.stdout)
                  agent.stdin.write(`${command}\n`)
                  agent.stdin.write('/bye\n')
                  agent.stdin.end()
                }
              )
            )
            await connectAgentAsync('Reload the agent', 'reloadagent')
            const keys = await core.group(
              'Read secret keys',
              () => new Promise(
                resolve => child_process.exec(
                  `gpg --batch --list-secret-keys --with-colons --with-keygrip ${fingerprint}`,
                  {},
                  (error, stdout, stderr) => {
                    if (stderr.length)
                      core.info(stderr.toString())
                    if (error)
                      return resolve(error)
                    const ctx = {}
                    const keys = {}
                    for (const line of stdout.toString().replace(/\r/g, '').trim().split(/\n/g)) {
                      const row = line.split(':').filter(column => column.length)
                      switch (row[0]) {
                      case 'fpr':
                        ctx.fingerprint = row[1]
                        keys[ctx.fingerprint] = {
                          keyId: ctx.keyId,
                          fingerprint: ctx.fingerprint,
                        }
                        if (ctx.isSubKey)
                          keys[ctx.fingerprint].originalKeyId = ctx.originalKeyId
                        break
                      case 'grp':
                        keys[ctx.fingerprint].keygrip = row[1]
                        break
                      case 'pub':
                        break
                      case 'sec':
                        ctx.originalKeyId = row[4]
                      case 'ssb':
                        ctx.isSubKey = row[0] === 'ssb'
                        ctx.keyId = row[4]
                        break
                      case 'tru':
                        break
                      case 'uid':
                        {
                          const { TZ } = env
                          env.TZ = 'Asia/Tokyo'
                          keys[ctx.fingerprint].user = {
                            email: row[4].split(' ')[1],
                            id: row[3],
                            name: row[4].split(' ')[0],
                            timestamp: new Date(Number(row[2]) * 1000).toLocaleString('ja'),
                          }
                          env.TZ = TZ
                        }
                        break
                      default:
                        return resolve(new Error(`Unknown property '${row[0]}', ${line}`))
                      }
                    }
                    core.info(JSON.stringify(keys, ' ', 2))
                    resolve(keys)
                  }
                )
              )
            )
            if ('message' in keys)
              return core.setFailed(keys.message)
            if (!(fingerprint in keys))
              return core.setFailed(`${fingerprint} is not found`)
            const key = keys[fingerprint]
            await connectAgentAsync(
              'Preset passphrase',
              `preset_passphrase ${key.keygrip} -1 ${passphrase}`
            )
            await connectAgentAsync('Show key info', `keyinfo ${key.keygrip}`)
            core.setOutput('key-id', key.keyId)
            core.setOutput('keygrip', key.keygrip)
      - env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        name: Create a commit and push it
        run: |
          echo keyinfo ${{ steps.gpg.outputs.keygrip }} | gpg-connect-agent
          git config --local user.email ${{ github.event.pusher.email }}
          git config --local user.name ${{ github.event.pusher.name }}
          git config --local user.signingkey ${{ steps.gpg.outputs.key-id }}!
          ref=${{ github.event.ref }}
          branch=${ref##*/}
          [[ "$(git branch --show-current)" = "$branch" ]] \
            || git checkout -b "$branch"
          git --no-pager log \
              --date=iso-local \
              --decorate \
              --pretty=fuller \
              --show-signature \
              -1
          message=":robot: Sign"
          git commit \
              --allow-empty \
              --gpg-sign=${{ steps.gpg.outputs.key-id }}! \
              --message "$message" \
              --signoff
          git --no-pager log \
              --date=iso-local \
              --decorate \
              --pretty=fuller \
              --show-signature \
              -1
          git push --set-upstream origin "$branch"
        shell: bash
name: GPG Sign
on:
  push:
    branches:
      - gpg-sign
  workflow_dispatch:
